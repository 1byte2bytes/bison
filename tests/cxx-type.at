# Checking the output filenames.                         -*- Autotest -*-
# Copyright 2000, 2001 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.

AT_BANNER([[C++ Type Syntax (GLR).]])

# _AT_TEST_GLR_CALC(`$1',DECL, RESOLVE1, RESOLVE2) 
# (first argument is a literal $1; it's a trick).  
# Store into types.y the calc program, with DECL inserted as a declaration,
# and with RESOLVE1 and RESOLVE2 as annotations on the conflicted rule for
# stmt.  Then compile the result.
m4_define([_AT_TEST_GLR_CALC],
[AT_DATA([types.y],
[[/* Simplified C++ Type and Expression Grammar */

$2

%{
  #include <stdio.h>
  #define YYSTYPE const char*
  static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog : 
     | prog stmt   { printf ("\n"); }
     ;

stmt : expr ';'  $3
     | decl      $4
     | error ';'
     | '@'  { YYACCEPT; }
     ;

expr : ID 		{ printf ("%s ", $$); }
     | TYPENAME '(' expr ')'  
			{ printf ("%s <cast> ", $1); }
     | expr '+' expr	{ printf ("+ "); }
     | expr '=' expr	{ printf ("= "); }
     ;

decl : TYPENAME declarator ';' 
			{ printf ("%s <declare> ", $1); }
     | TYPENAME declarator '=' expr ';'
			{ printf ("%s <init-declare> ", $1); }
     ;

declarator : ID		{ printf ("\"%s\" ", $1); }
     | '(' declarator ')'
     ;

%%

#include <ctype.h>
#include <strings.h>

main (int argc, char** argv) 
{
  freopen (argv[1], "r", stdin);
  exit (yyparse ());
}

#if YYPURE
int yylex (YYSTYPE *lvalp)
#define yylval (*lvalp)
#else
int yylex ()
#endif
{
  char buffer[256];
  int c;
  while (1) {
    c = getchar ();
    switch (c) {
    case EOF:
      return 0;
    case ' ': case '\t': case '\n': case '\f':
      break;
    default:
      if (isalpha (c)) {
	ungetc (c, stdin);
	scanf ("%[A-Za-z0-9_]", buffer);
	yylval = strdup (buffer);
	return isupper (buffer[0]) ? TYPENAME : ID;
      }
      return c;
    }
  }
}

int
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
  return 0;
}

static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  printf ("<OR> ");
  return "";
}
]])

AT_DATA([test-input],
[[

z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
]])

AT_CHECK([bison types.y], 0, [], ignore)
AT_CHECK([gcc -o types types.tab.c], 0, [], ignore)
])

m4_define([_AT_RESOLVED_GLR_OUTPUT],
[[z q +
"x" T <declare>
"x" y T <init-declare>
x y =
x T <cast> y +
"x" T <declare>
"y" z q + T <init-declare>
y
z q +
]])

m4_define([_AT_AMBIG_GLR_OUTPUT],
[[z q + 
"x" T <declare> 
"x" y T <init-declare> 
x y = 
x T <cast> y + 
"x" T <declare> x T <cast> <OR> 
"y" z q + T <init-declare> y T <cast> z q + = <OR> 
y
z q +
]])

m4_define([_AT_GLR_STDERR], 
[[parse error
]])

m4_define([_AT_VERBOSE_GLR_STDERR], 
[[parse error, unexpected ID, expecting '=' or '+' or ')'
]])

## ---------------------------------------------------- ##
## Compile the grammar described in the documentation.  ##
## ---------------------------------------------------- ##

AT_SETUP([GLR: Resolve ambiguity, impure, no locations])
_AT_TEST_GLR_CALC([$1],[],[%dprec 1],[%dprec 2])
AT_CHECK([[./types test-input | sed 's/  *$//']], 0, _AT_RESOLVED_GLR_OUTPUT, 
	 _AT_GLR_STDERR)
AT_CLEANUP

AT_SETUP([GLR: Resolve ambiguity, impure, locations])
_AT_TEST_GLR_CALC([$1],[%locations],[%dprec 1],[%dprec 2])
AT_CHECK([[./types test-input | sed 's/  *$//']], 0, _AT_RESOLVED_GLR_OUTPUT, 
	_AT_GLR_STDERR)
AT_CLEANUP

AT_SETUP([GLR: Resolve ambiguity, pure, no locations])
_AT_TEST_GLR_CALC([$1],[%pure-parser],[%dprec 1],[%dprec 2])
AT_CHECK([[./types test-input | sed 's/  *$//']], 0, _AT_RESOLVED_GLR_OUTPUT,
	 _AT_GLR_STDERR)
AT_CLEANUP

AT_SETUP([GLR: Resolve ambiguity, pure, locations])
_AT_TEST_GLR_CALC([$1],[%pure-parser
%locations],[%dprec 1],[%dprec 2])
AT_CHECK([[./types test-input | sed 's/  *$//']], 0, _AT_RESOLVED_GLR_OUTPUT, 
	 _AT_GLR_STDERR)
AT_CLEANUP

AT_SETUP([GLR: Merge conflicting parses, impure, no locations])
_AT_TEST_GLR_CALC([$1],[],[%merge <stmtMerge>],[%merge <stmtMerge>])
AT_CHECK([[./types test-input | sed 's/  *$//']], 0, _AT_AMBIG_GLR_OUTPUT, 
	 _AT_GLR_STDERR)
AT_CLEANUP

AT_SETUP([GLR: Merge conflicting parses, impure, locations])
_AT_TEST_GLR_CALC([$1],[%locations],[%merge <stmtMerge>],[%merge <stmtMerge>])
AT_CHECK([[./types test-input | sed 's/  *$//']], 0, _AT_AMBIG_GLR_OUTPUT, 
	 _AT_GLR_STDERR)
AT_CLEANUP

AT_SETUP([GLR: Merge conflicting parses, pure, no locations])
_AT_TEST_GLR_CALC([$1],[%pure-parser],[%merge <stmtMerge>],[%merge <stmtMerge>])
AT_CHECK([[./types test-input | sed 's/  *$//']], 0, _AT_AMBIG_GLR_OUTPUT, 
	 _AT_GLR_STDERR)
AT_CLEANUP
AT_SETUP([GLR: Merge conflicting parses, pure, locations])
_AT_TEST_GLR_CALC([$1],[%pure-parser
%locations],[%merge <stmtMerge>],[%merge <stmtMerge>])
AT_CHECK([[./types test-input | sed 's/  *$//']], 0, _AT_AMBIG_GLR_OUTPUT, 
	 _AT_GLR_STDERR)
AT_CLEANUP

AT_SETUP([GLR: Verbose messages, resolve ambiguity, impure, no locations])
_AT_TEST_GLR_CALC([$1],[%error-verbose],
[%merge <stmtMerge>],[%merge <stmtMerge>])
AT_CHECK([[./types test-input | sed 's/  *$//']], 0, 
	 _AT_AMBIG_GLR_OUTPUT, _AT_VERBOSE_GLR_STDERR)
AT_CLEANUP
