# Java tests for simple calculator.           -*- Autotest -*-

# Copyright (C) 2007 Free Software Foundation, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

AT_BANNER([[Java Calculator.]])


# ------------------------- #
# Helping Autotest macros.  #
# ------------------------- #


# _AT_DATA_JAVA_CALC_Y($1, $2, $3, [BISON-DIRECTIVES])
# ----------------------------------------------------------------------
# Produce `calc.y'.  Don't call this macro directly, because it contains
# some occurrences of `$1' etc. which will be interpreted by m4.  So
# you should call it with $1, $2, and $3 as arguments, which is what
# AT_DATA_JAVA_CALC_Y does.
m4_define([_AT_DATA_JAVA_CALC_Y],
[m4_if([$1$2$3], $[1]$[2]$[3], [],
       [m4_fatal([$0: Invalid arguments: $@])])dnl
AT_DATA([Calc.y],
[[/* Infix notation calculator--calc */
%language "Java"
%name-prefix "Calc"
%define parser_class_name "Calc"
%define public

]$4[

%code imports {
  import java.io.StreamTokenizer;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.Reader;
  import java.io.IOException;
}

/* Bison Declarations */
%token <Integer> NUM "number"
%type  <Integer> exp

%nonassoc '=' /* comparison            */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line
;

line:
  '\n'
| exp '\n'
| error '\n'
;

exp:
  NUM                { $$ = $1;                                             }
| exp '=' exp
  {
    if ($1.intValue () != $3.intValue ())
      yyerror ("calc: error: " + $1 + " != " + $3);
  }
| exp '+' exp        { $$ = new Integer ($1.intValue () + $3.intValue ());  }
| exp '-' exp        { $$ = new Integer ($1.intValue () - $3.intValue ());  }
| exp '*' exp        { $$ = new Integer ($1.intValue () * $3.intValue ());  }
| exp '/' exp        { $$ = new Integer ($1.intValue () / $3.intValue ());  }
| '-' exp  %prec NEG { $$ = new Integer (-$2.intValue ());                  }
| exp '^' exp        { $$ = new Integer ((int)
                                         Math.pow ($1.intValue (),
                                                   $3.intValue ()));        }
| '(' exp ')'        { $$ = $2;                                             }
| '(' error ')'      { $$ = new Integer (1111);                             }
| '!'                { $$ = new Integer (0); return YYERROR;                }
| '-' error          { $$ = new Integer (0); return YYERROR;                }
;

]AT_LEXPARAM_IF([[
%code lexer {
]],
[[
%%
class CalcLexer implements Calc.Lexer {
]])[
  StreamTokenizer st;

  public ]AT_LEXPARAM_IF([[YYLexer]], [[CalcLexer]]) (InputStream is)
  {
    st = new StreamTokenizer (new InputStreamReader (is));
    st.resetSyntax ();
    st.eolIsSignificant (true);
    st.whitespaceChars (9, 9);
    st.whitespaceChars (32, 32);
    st.wordChars (48, 57);
  }

AT_LOCATION_IF([[
  Position yystartpos;
  Position yyendpos = new Position (1);

  public Position getStartPos() {
    return yystartpos;
  }

  public Position getEndPos() {
    return yyendpos;
  }

  public void yyerror (Calc.Location l, String s)
  {
    if (l == null)
      System.err.println (s);
    else
      System.err.println (l.begin + ": " + s);
  }
]], [[
  public void yyerror (String s)
  {
    System.err.println (s); 
  }
]])[

  Integer yylval;

  public Object getLVal() {
    return yylval;
  }

  public int yylex () throws IOException {
    int ttype = st.nextToken ();
    ]AT_LOCATION_IF([[yystartpos = yyendpos;]])[
    if (ttype == st.TT_EOF)
      return Calc.EOF;

    else if (ttype == st.TT_EOL)
      {
        ]AT_LOCATION_IF([[yyendpos = new Position (yyendpos.lineno () + 1);]])[
        return (int) '\n';
      }

    else if (ttype == st.TT_WORD)
      {
        yylval = new Integer (st.sval);
        return Calc.NUM;
      }

    else
      return st.ttype;
  }


]AT_LEXPARAM_IF([[
};
%%]], [[
}]])

[
class Position {
  public int line;

  public Position ()
  {
    line = 0;
  }

  public Position (int l)
  {
    line = l;
  }

  public long getHashCode ()
  {
    return line;
  }

  public boolean equals (Position l)
  {
    return l.line == line;
  }

  public String toString ()
  {
    return Integer.toString (line);
  }

  public int lineno ()
  {
    return line;
  }
}

]])
])# _AT_DATA_JAVA_CALC_Y


# AT_DATA_CALC_Y([BISON-OPTIONS])
# -------------------------------------------------
# Produce `calc.y'.
m4_define([AT_DATA_JAVA_CALC_Y],
[_AT_DATA_JAVA_CALC_Y($[1], $[2], $[3], [$1])
])



# AT_JAVA_COMPILE(SOURCE)
# -----------------------
# Compile SOURCES into Java class files.  Skip the test if java or javac is
# not installed.
m4_define([AT_JAVA_COMPILE],
[AT_CHECK([test -n "$CONF_JAVA" || exit 77
test -n "$CONF_JAVAC" || exit 77])
AT_CHECK([$SHELL ../../../javacomp.sh $1],
         0, [ignore], [ignore])])


# AT_JAVA_PARSER_CHECK(COMMAND, EXIT-STATUS, EXPOUT, EXPERR, [PRE])
# -----------------------------------------------------------------
m4_define([AT_JAVA_PARSER_CHECK],
[AT_CHECK([$5 $SHELL ../../../javaexec.sh $1], [$2], [$3], [$4])])


# _AT_CHECK_JAVA_CALC_ERROR(BISON-OPTIONS, INPUT,
#                           [VERBOSE-AND-LOCATED-ERROR-MESSAGE])
# ---------------------------------------------------------
# Run `calc' on INPUT, and expect a `syntax error' message.
#
# If INPUT starts with a slash, it is used as absolute input file name,
# otherwise as contents.
#
# The VERBOSE-AND-LOCATED-ERROR-MESSAGE is stripped of locations
# and expected tokens if necessary, and compared with the output.
m4_define([_AT_CHECK_JAVA_CALC_ERROR],
[m4_bmatch([$2], [^/],
           [AT_JAVA_PARSER_CHECK([Calc < $2], 0, [], [stderr])],
           [AT_DATA([[input]],
[[$2
]])
AT_JAVA_PARSER_CHECK([Calc < input], 0, [], [stderr])])

# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Create the reference error message.
AT_DATA([[expout]],
[$3
])
# 2. If locations are not used, remove them.
AT_YYERROR_SEES_LOC_IF([],
[[sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout]])
# 3. If error-verbose is not used, strip the`, unexpected....' part.
m4_bmatch([$1], [%error-verbose], [],
[[sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout]])
# 4. Check
AT_CHECK([cat stderr], 0, [expout])
])

# _AT_CHECK_JAVA_CALC([BISON-DIRECTIVES], [BISON-CODE])
# -----------------------------------------------------------------------
# Start a testing chunk which compiles `calc' grammar with
# BISON-DIRECTIVES, and performs several tests over the parser.
m4_define([_AT_CHECK_JAVA_CALC],
[# We use integers to avoid dependencies upon the precision of doubles.
AT_SETUP([Calculator $1])

AT_BISON_OPTION_PUSHDEFS([$1])

AT_DATA_JAVA_CALC_Y([$1
%code {
$2
}])

AT_CHECK([bison -o Calc.java Calc.y])
AT_JAVA_COMPILE([Calc.java])

# Test the priorities.
AT_DATA([[input]],
[[1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
]])
AT_JAVA_PARSER_CHECK([Calc < input], 0, [], [stderr])


# Some syntax errors.
_AT_CHECK_JAVA_CALC_ERROR([$1], [0 0],
                          [1: syntax error, unexpected number])
_AT_CHECK_JAVA_CALC_ERROR([$1], [1//2],
                          [1: syntax error, unexpected '/', expecting number or '-' or '(' or '!'])
_AT_CHECK_JAVA_CALC_ERROR([$1], [error],
                          [1: syntax error, unexpected $undefined])
_AT_CHECK_JAVA_CALC_ERROR([$1], [1 = 2 = 3],
                          [1: syntax error, unexpected '='])
_AT_CHECK_JAVA_CALC_ERROR([$1], [
+1],
                          [2: syntax error, unexpected '+'])
# Exercise error messages with EOF: work on an empty file.
_AT_CHECK_JAVA_CALC_ERROR([$1], [/dev/null],
                          [1: syntax error, unexpected end of input])

# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
_AT_CHECK_JAVA_CALC_ERROR([$1], 
                          [() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1],
[1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected ')', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
calc: error: 4444 != 1])

# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
_AT_CHECK_JAVA_CALC_ERROR([$1], [(!) + (0 0) = 1],
[1: syntax error, unexpected number
calc: error: 2222 != 1])
_AT_CHECK_JAVA_CALC_ERROR([$1], [(- *) + (0 0) = 1],
[1: syntax error, unexpected '*', expecting number or '-' or '(' or '!'
1: syntax error, unexpected number
calc: error: 2222 != 1])
AT_BISON_OPTION_POPDEFS

AT_CLEANUP
])# _AT_CHECK_JAVA_CALC


# AT_CHECK_JAVA_CALC([BISON-DIRECTIVES])
# --------------------------------------------------------
# Start a testing chunk which compiles `calc' grammar with
# BISON-DIRECTIVES, and performs several tests over the parser.
# Run the test with and without %error-verbose.
m4_define([AT_CHECK_JAVA_CALC],
[_AT_CHECK_JAVA_CALC([$1], [$2])
_AT_CHECK_JAVA_CALC([%error-verbose $1], [$2])
_AT_CHECK_JAVA_CALC([%locations $1], [$2])
_AT_CHECK_JAVA_CALC([%error-verbose %locations $1], [$2])
])# AT_CHECK_JAVA_CALC


# ------------------------ #
# Simple LALR Calculator.  #
# ------------------------ #

AT_CHECK_JAVA_CALC([], [[
  public static void main (String args[]) throws IOException
  {
    CalcLexer l = new CalcLexer (System.in);
    Calc p = new Calc (l);
    p.parse ();
  }
]])

AT_CHECK_JAVA_CALC([%lex-param { InputStream is } ], [[
  public static void main (String args[]) throws IOException
  {
    new Calc (System.in).parse ();
  }
]])
