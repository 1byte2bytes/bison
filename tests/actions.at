# Executing Actions.                               -*- Autotest -*-
# Copyright 2001 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.

AT_BANNER([[User Actions.]])

## ------------------ ##
## Mid-rule actions.  ##
## ------------------ ##

AT_SETUP([Mid-rule actions])

# Bison once forgot the mid-rule actions.  It was because the action
# was attached to the host rule (the one with the mid-rule action),
# instead of being attached to the empty rule dedicated to this
# action.

AT_DATA([[input.y]],
[[%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define YYDEBUG         1
# define YYERROR_VERBOSE 1
%}
%%
exp:     { putchar ('0'); }
     '1' { putchar ('1'); }
     '2' { putchar ('2'); }
     '3' { putchar ('3'); }
     '4' { putchar ('4'); }
     '5' { putchar ('5'); }
     '6' { putchar ('6'); }
     '7' { putchar ('7'); }
     '8' { putchar ('8'); }
     '9' { putchar ('9'); }
         { putchar ('\n'); }
   ;
%%
static int
yylex (void)
{
  static const char *input = "123456789";
  return *input++;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
]])

AT_CHECK([bison input.y -d -v -o input.c])
AT_CHECK([$CC $CFLAGS $CPPFLAGS input.c -o input], 0, [], [ignore])
AT_CHECK([./input], 0,
[[0123456789
]])

AT_CLEANUP



## ---------------- ##
## Exotic Dollars.  ##
## ---------------- ##

AT_SETUP([Exotic Dollars])

AT_DATA([[input.y]],
[[%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define YYDEBUG         1
# define YYERROR_VERBOSE 1
%}

%union
{
  int val;
};

%type <val> a_1 a_2 a_4 a_5
            sum_of_the_five_previous_values

%%
exp: a_1 a_2 { $<val>$ = 3; } a_4 a_5 sum_of_the_five_previous_values
    {
       printf ("%d\n", $6);
    }
;
a_1: { $$ = 1; };
a_2: { $$ = 2; };
a_4: { $$ = 4; };
a_5: { $$ = 5; };

sum_of_the_five_previous_values:
    {
       $$ = $<val>0 + $<val>-1 + $<val>-2 + $<val>-3 + $<val>-4;
    }
;

%%
static int
yylex (void)
{
  return EOF;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
]])

AT_CHECK([bison input.y -d -v -o input.c])
AT_CHECK([$CC $CFLAGS $CPPFLAGS input.c -o input], 0, [], [ignore])
AT_CHECK([./input], 0,
[[15
]])

AT_CLEANUP



## ------------- ##
## Destructors.  ##
## ------------- ##

AT_SETUP([Destructors])

# Make sure complex $n work.

AT_DATA([[input.y]],
[[%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#define YYERROR_VERBOSE 1
#define YYDEBUG 1
/* #define YYPRINT yyprint */

static int yylex (void);
static void yyerror (const char *msg);
static void yyprint (FILE *out, int toknum, int tokval);
%}

%union
{
  int ival;
}
%type <ival> thing 'x'
%destructor { printf ("Freeing thing %d\n", $$); } thing
%destructor { printf ("Freeing 'x' %d\n", $$); } 'x'

%%
input:
  /* Nothing. */
| input line
;

line:
  thing thing thing ';'
    { printf ("input: thing(%d) thing(%d) thing(%d) ';'\n", $1, $2, $3); }
| thing thing ';'
    { printf ("input: thing(%d) thing(%d) ';'\n", $1, $2); }
| thing ';'
    { printf ("input: thing(%d) ';'\n", $1); }
| error ';'
    { printf ("input: error ';'\n"); }
;

thing:
  'x'  { printf ("thing: 'x' (%d)\n", $1); $$ = $1; }
;
%%
static int
yylex (void)
{
  static const int input[] =
    {
      'x', 'x', 'x', 'x', 'x', 'x', ';',
      'x', 'x', ';',
      'x', ';',
      'x', 'y', ';'
    };
  static int counter = 0;

  if (counter < (sizeof(input) / sizeof (input[0])))
    {
       yylval.ival = counter;
       return input[counter++];
    }
  else
    return EOF;
}

static void
yyerror (const char *msg)
{
  fprintf (stdout, "%s\n", msg);
}

static void
yyprint (FILE *out, int toknum, int tokval)
{
  if (0 < toknum && toknum < 256)
    fprintf (out, " = %d", tokval);
}

int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  if (yyparse ())
    {
      fprintf (stdout, "Parsing FAILED.\n");
      exit (1);
    }
  fprintf (stdout, "Successful parse.\n");
  return 0;
}
]])

AT_CHECK([bison input.y -d -v -o input.c])
AT_CHECK([$CC $CFLAGS $CPPFLAGS input.c -o input], 0, [], [ignore])
AT_CHECK([./input], 0,
[[thing: 'x' (0)
thing: 'x' (1)
thing: 'x' (2)
parse error, unexpected 'x', expecting ';'
Freeing thing 2
Freeing thing 1
Freeing thing 0
Freeing 'x' 3
Freeing 'x' 4
Freeing 'x' 5
input: error ';'
thing: 'x' (7)
thing: 'x' (8)
input: thing(7) thing(8) ';'
thing: 'x' (10)
input: thing(10) ';'
thing: 'x' (12)
parse error, unexpected $undefined., expecting 'x' or ';'
Freeing thing 12
input: error ';'
Successful parse.
]])

AT_CLEANUP
